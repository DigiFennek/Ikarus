//***************************************************************************
//* IKARUS HELIKOPTER-SIMULATOR
//***************************************************************************
//*
//*  - Grafikroutinen
//*
//***************************************************************************

#include "ikarus2.h"
#include <dos.h>
#include <alloc.h>
#include <stdlib.h>

// Zeiger auf Bildbuffer
char far *scrBuffer = MK_FP (0xA000, 0);

void setdata (int segm, int off, int count, char value)
{
  // Initialisiert 'count' Bytes bei 'segm:off' mit 'value'
  asm	cld
  asm	mov es,segm
  asm	mov di,off
  asm	mov al,value
  asm	mov ah,al
  asm	mov cx,count
  asm	shr cx,1
  asm	rep stosw
  asm	jnb _setdataend
  asm	stosb
_setdataend:
  asm
}


void movenonzero (int srcSeg, int srcOff, int destSeg, int destOff, int n)
{
  // Kopiert 'n' Bytes die ungleich Null sind von 'srcSeg:srcOff'
  // nach 'destSeg:destOff'
  asm push ds
  asm cld
  asm mov ds,srcSeg
  asm mov si,srcOff
  asm mov es,destSeg
  asm mov di,destOff
  asm mov cx,n
  asm cmp cx,0
  asm jz _movenonzeroend
_movenonzeroloop:
  asm cmp byte ptr ds:[si],0
  asm jz _movenonzeronomove
  asm movsb
  asm loop _movenonzeroloop
  asm jmp _movenonzeroend
_movenonzeronomove:
  asm inc si
  asm inc di
  asm loop _movenonzeroloop
_movenonzeroend:
  asm pop ds
}


void scanLine (int x1, int x2, int y, int color)
{
  char far *scr = scrBuffer + (y << 8) + (y << 6) + x1;
  int count = (x2 - x1) + 1;

  // Fuellt den bereich 'x1,x2,y' mit der Farbe color
  switch (color & 0xFF00)
  {
    case METALLICFILL:
      color += (y & 0x10) ? (y & 0x0F) : (15 - (y & 0x0F));
    case SOLIDFILL:
      setdata (FP_SEG (scr), FP_OFF (scr), count, color);
    break;

    case PLAIDFILL:
      scr += (x1 + y) & 1;
      count /= 2;
      while (count--)
      {
	*scr = color;
	 scr += 2;
      }
    break;

    case SHADOWFILL:
      scr += (x1 + y) & 1;
      count /= 2;
      while (count--)
      {
	*scr &= 0xF7;
	 scr += 2;
      }
    break;
  }
}


void fillPoly (int polySize, struct POINT poly[], int fColor, int bColor)
{
  // Fuellt ein Polygon definiert durch die Eckpunkte 'poly[polySize]' mit
  // der Farbe 'fColor' und der Randfarbe 'bColor'
  struct POINT *nextEdge1, *nextEdge2;
  struct POINT *topEdge = &poly[0];
  struct POINT *lastEdge = &poly[polySize - 1];
  struct POINT *firstEdge = &poly[0];

  int ey, sy;
  int x1, x2, x3, x4, i, div;
  int sx1, sx2, slope1, slope2;

  for (i = 1; i < polySize; i++)
    if (poly[i].y < topEdge->y) topEdge = &poly[i];

  nextEdge1 = nextEdge2 = topEdge;
  sy = ey = topEdge->y;
  x2 = x3 = topEdge->x;

  while (polySize > 0)
  {
    if (ey == nextEdge1->y)
    {
      struct POINT *activeEdge1 = nextEdge1;

      nextEdge1 = (nextEdge1 == lastEdge) ? firstEdge : nextEdge1 + 1;

      if ((div = (nextEdge1->y - activeEdge1->y) + 1) != 0)
	slope1 = ((nextEdge1->x - activeEdge1->x) << 6) / div;
      else
	slope1 = 0;

      sx1 = activeEdge1->x << 6;

      polySize--;
    }

    if (ey == nextEdge2->y)
    {
      struct POINT *activeEdge2 = nextEdge2;

      nextEdge2 = (nextEdge2 == firstEdge) ? lastEdge : nextEdge2 - 1;

      if ((div = (nextEdge2->y - activeEdge2->y) + 1) != 0)
	slope2 = ((nextEdge2->x - activeEdge2->x) << 6) / div;
      else
	slope2 = 0;

      sx2 = activeEdge2->x << 6;

      polySize--;
    }

    ey = min (nextEdge1->y, nextEdge2->y);

    while (sy < ey)
    {
      x1 = (sx1 += slope1) >> 6;
      x4 = (sx2 += slope2) >> 6;

      scanLine (min (x2, x3), max (x2, x3), sy, fColor);
      scanLine (min (x3, x4), max (x3, x4), sy, bColor);
      scanLine (min (x1, x2), max (x1, x2), sy, bColor);

      x2 = x1; x3 = x4;
      sy++;
    }

    x1 = (sx1 + slope1) >> 6;
    x4 = (sx2 + slope2) >> 6;

    scanLine (min (x1, x2), max (x1, x2), sy, bColor);
    scanLine (min (x3, x4), max (x3, x4), sy, bColor);
  }
}


void drawLine (int x1, int y1, int x2, int y2, int color)
{
  // Zeichnet eine Linie von 'x1,y1' nach 'x2,y2' mit der Farbe 'color'
  int sx, slope, sy, scry, temp;

  if (y1 > y2)
  {
    temp = y1; y1 = y2; y2 = temp;
    temp = x1; x1 = x2; x2 = temp;
  }

  slope = ((x2 - x1) << 6) / ((y2 - y1) + 1);

  sx = x1 << 6;

  for (sy = y1; sy <= y2; sy++)
  {
    sx += slope;
    x2 = sx >> 6;

    scanLine (min (x1, x2), max (x1, x2), sy, color);

    x1 = x2;
  }
}


void polyLine (int polySize, struct POINT poly[], int color)
{
  // Zeichned ein geschlossenes Polygon definiert durch die Eckpunkte
  // 'poly[polySize]' mit der Farbe 'color'
  int x1, x2, y1, y2;

  x1 = poly[polySize-1].x;
  y1 = poly[polySize-1].y;

  while (polySize-- > 0)
  {
    x2 = poly->x;
    y2 = poly->y;
    poly++;

    drawLine (x1, y1, x2, y2, color);

    x1 = x2; y1 = y2;
  }
}


void putPixel (int x, int y, int color)
{
  // Zeichnet ein Pixel an der Position 'x,y' mit der Farbe 'color'
  if ((y >= MINCLIPY) && (y <= MAXCLIPY) &&
      (x >= MINCLIPX) && (x <= MAXCLIPX))
  {
    scanLine (x, x, y, color);
  }
}


void fillCircle (int x, int y, int d, int color)
{
  // Fuellt ein Kreis an der Position 'x,y', Durchmesser 'd' mit der
  // Farbe 'color'
  int r = (d >> 1);
  int a = 0, b = r;
  int error = 1 - r;

  if (((x + r) >= MINCLIPX) && ((x - r) <= MAXCLIPX) &&
      ((y + r) >= MINCLIPY) && ((y - r) <= MAXCLIPY))
  {
    while (a <= b)
    {
      int xa1 = max (x - a, MINCLIPX);
      int xa2 = min (x + a, MAXCLIPX);
      int xb1 = max (x - b, MINCLIPX);
      int xb2 = min (x + b, MAXCLIPX);

      if ((xa1 < MAXCLIPX) && (xa2 >= MINCLIPX))
      {
	int yb1 = y - b;
	int yb2 = y + b;

	if ((yb1 >= MINCLIPY) && (yb1 <= MAXCLIPY))
	  scanLine (xa1, xa2, yb1, color);

	if ((yb2 >= MINCLIPY) && (yb2 <= MAXCLIPY))
	  scanLine (xa1, xa2, yb2, color);
      }

      if ((xb1 < MAXCLIPX) && (xb2 >= MINCLIPX))
      {
	int ya1 = y - a;
	int ya2 = y + a;

	if ((ya1 >= MINCLIPY) && (ya1 <= MAXCLIPY))
	  scanLine (xb1, xb2, ya1, color);

	if ((ya2 >= MINCLIPY) && (ya2 <= MAXCLIPY))
	  scanLine (xb1, xb2, ya2, color);
      }

      a++;

      if (error >= 0)
      {
	b--;
	error -= (b << 1);
      }

      error += ((a << 1) + 1);
    }
  }
}


void putImage (int x, int y, char *image, int ix, int iy)
{
  char far *scr = scrBuffer + (y << 8) + (y << 6) + x;
  int i;

  if (image != NULL)
    for (i = 0; i < iy; i++)
    {
      movenonzero (FP_SEG (image), FP_OFF (image),
		   FP_SEG (scr), FP_OFF (scr), ix);

      scr += 320;
      image += ix;
    }

  else
    for (i = 0; i < iy; i++)
    {
      setdata (FP_SEG (scr), FP_OFF (scr), ix, 0);

      scr += 320;
      image += ix;
    }
}


int initVGA (void)
{
  // initialisiert den Bildschirmmodus 19 (VGA 320 x 200, 256 Farben)
  union REGS reg;

  reg.x.ax = 0x0013;
  int86 (0x10, &reg, &reg);

  reg.x.ax = 0x0F00;
  int86 (0x10, &reg, &reg);

  if (reg.h.al != 0x13) return FALSE;

  if ((scrBuffer = farmalloc (65536)) == NULL)
    scrBuffer = MK_FP (0xA000, 0);

  setdata  (FP_SEG (scrBuffer), FP_OFF (scrBuffer), 64000, 0);
  setdata  (0xA000, 0, 64000, 0);

  return TRUE;
}


void initText (void)
{
  // initialisiert den Textmodus 4
  union REGS reg;

  reg.x.ax = 0x0003;
  int86 (0x10, &reg, &reg);

  if (scrBuffer != MK_FP (0xA000, 0))
    farfree (scrBuffer);
}


void setPalette (char color, char r, char g, char b)
{
  asm 	mov dx,03C8h
  asm   mov al,color
  asm   out dx,al

  asm 	mov dx,03c9h
  asm 	mov al,r
  asm   shr al,1
  asm   shr al,1
  asm 	out dx,al
  asm 	mov al,g
  asm   shr al,1
  asm   shr al,1
  asm 	out dx,al

  asm 	mov dx,03dah

  loop1:
  asm 	in  al,dx
  asm 	and al,1
  asm 	cmp al,1
  asm 	je  loop1

  loop2:
  asm 	in  al,dx
  asm 	and al,1
  asm 	cmp al,0
  asm 	je  loop2

  asm 	mov al,b
  asm   shr al,1
  asm   shr al,1
  asm 	mov dx,03c9h
  asm 	out dx,al
}

unsigned char r[256], g[256], b[256];

void setColorPalette (int color, char red, char green, char blue, int direct)
{
  r[color] = red;
  g[color] = green;
  b[color] = blue;

  if (direct)
    setPalette (color, red, green, blue);
}


void fadePalette (int steps)
{
  int i, k, p, s = abs (steps);

  if (steps)
    for (i = 0; i <= s; i++)
    {
      p = (steps < 0) ? s - i : i;
      for (k = 0; k <= 255; k++)
	setPalette (k, (r[k] * p) / s, (g[k] * p) / s, (b[k] * p) / s);
    }
}


void initColorPalette (char far *palette, int begin, int end)
{
  int i;

  if (palette != NULL)
    for (i = begin; i <= end; i++)
      setColorPalette (i, *palette++, *palette++, *palette++, FALSE);
}


void flipScreen (void)
{
  movedata (FP_SEG (scrBuffer), FP_OFF (scrBuffer), 0xA000, 0, 64000);
}


char font8x10[128*11] =
{
    /*	 */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x05,0xF8,0xC0,0xA0,0x90,0x88,0x88,0x90,0xA0,0xC0,0xF8,
    /*	 */ 0x05,0xF8,0x18,0x28,0x48,0x88,0x88,0x48,0x28,0x18,0xF8,
    /*	 */ 0x05,0xF8,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xF8,
    /*	 */ 0x05,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0xF8,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ! */ 0x02,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x80,0x00,
    /* " */ 0x04,0x00,0xA0,0xA0,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,
    /* # */ 0x06,0x00,0x28,0x28,0xF8,0x50,0x50,0xF8,0xA0,0xA0,0x00,
    /* $ */ 0x06,0x00,0x70,0xA8,0xA0,0x70,0x28,0x28,0xA8,0x70,0x20,
    /* % */ 0x09,0x00,0x62,0x94,0x94,0x68,0x16,0x29,0x29,0x46,0x00,
    /* & */ 0x07,0x00,0x30,0x48,0x48,0x30,0x50,0x8C,0x88,0x74,0x00,
    /* ' */ 0x03,0x00,0x40,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ( */ 0x04,0x20,0x40,0x80,0x80,0x80,0x80,0x80,0x80,0x40,0x20,
    /* ) */ 0x04,0x80,0x40,0x20,0x20,0x20,0x20,0x20,0x20,0x40,0x80,
    /* * */ 0x06,0x00,0x00,0x00,0x20,0xA8,0x70,0xA8,0x20,0x00,0x00,
    /* + */ 0x06,0x00,0x00,0x00,0x20,0x20,0xF8,0x20,0x20,0x00,0x00,
    /* , */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x80,
    /* - */ 0x04,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,
    /* . */ 0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,
    /* / */ 0x05,0x00,0x10,0x10,0x20,0x20,0x20,0x20,0x40,0x40,0x00,
    /* 0 */ 0x06,0x00,0x70,0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00,
    /* 1 */ 0x04,0x00,0x20,0x60,0xA0,0x20,0x20,0x20,0x20,0x20,0x00,
    /* 2 */ 0x06,0x00,0x70,0x88,0x08,0x08,0x10,0x20,0x40,0xF8,0x00,
    /* 3 */ 0x06,0x00,0x70,0x88,0x08,0x30,0x08,0x08,0x88,0x70,0x00,
    /* 4 */ 0x06,0x00,0x10,0x30,0x50,0x50,0x90,0xF8,0x10,0x10,0x00,
    /* 5 */ 0x06,0x00,0x78,0x40,0x80,0xF0,0x08,0x08,0x88,0x70,0x00,
    /* 6 */ 0x06,0x00,0x70,0x88,0x80,0xF0,0x88,0x88,0x88,0x70,0x00,
    /* 7 */ 0x06,0x00,0xF8,0x08,0x10,0x20,0x20,0x40,0x40,0x40,0x00,
    /* 8 */ 0x06,0x00,0x70,0x88,0x88,0x70,0x88,0x88,0x88,0x70,0x00,
    /* 9 */ 0x06,0x00,0x70,0x88,0x88,0x88,0x78,0x08,0x88,0x70,0x00,
    /* : */ 0x02,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,
    /* ; */ 0x03,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x40,0x40,0x80,
    /* < */ 0x06,0x00,0x00,0x00,0x08,0x70,0x80,0x70,0x08,0x00,0x00,
    /* = */ 0x06,0x00,0x00,0x00,0x00,0xF8,0x00,0xF8,0x00,0x00,0x00,
    /* > */ 0x06,0x00,0x00,0x00,0x80,0x70,0x08,0x70,0x80,0x00,0x00,
    /* ? */ 0x06,0x00,0x70,0x88,0x08,0x10,0x20,0x20,0x00,0x20,0x00,
    /* @ */ 0x09,0x00,0x3C,0x42,0x99,0xA5,0xA5,0xAD,0x96,0x40,0x3E,
    /* A */ 0x08,0x00,0x10,0x28,0x28,0x28,0x44,0x7C,0x82,0x82,0x00,
    /* B */ 0x07,0x00,0xF8,0x84,0x84,0xF8,0x84,0x84,0x84,0xF8,0x00,
    /* C */ 0x07,0x00,0x38,0x44,0x80,0x80,0x80,0x80,0x44,0x38,0x00,
    /* D */ 0x07,0x00,0xF0,0x88,0x84,0x84,0x84,0x84,0x88,0xF0,0x00,
    /* E */ 0x06,0x00,0xF8,0x80,0x80,0xF8,0x80,0x80,0x80,0xF8,0x00,
    /* F */ 0x06,0x00,0xF8,0x80,0x80,0xF0,0x80,0x80,0x80,0x80,0x00,
    /* G */ 0x08,0x00,0x38,0x44,0x82,0x80,0x8E,0x82,0x44,0x38,0x00,
    /* H */ 0x07,0x00,0x84,0x84,0x84,0xFC,0x84,0x84,0x84,0x84,0x00,
    /* I */ 0x02,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,
    /* J */ 0x05,0x00,0x10,0x10,0x10,0x10,0x10,0x90,0x90,0x60,0x00,
    /* K */ 0x07,0x00,0x84,0x88,0x90,0xB0,0xD0,0x88,0x88,0x84,0x00,
    /* L */ 0x06,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xF8,0x00,
    /* M */ 0x08,0x00,0x82,0xC6,0xC6,0xAA,0xAA,0xAA,0x92,0x92,0x00,
    /* N */ 0x08,0x00,0x84,0xC4,0xA4,0xA4,0x94,0x94,0x8C,0x84,0x00,
    /* O */ 0x08,0x00,0x38,0x44,0x82,0x82,0x82,0x82,0x44,0x38,0x00,
    /* P */ 0x07,0x00,0xF8,0x84,0x84,0xF8,0x80,0x80,0x80,0x80,0x00,
    /* Q */ 0x08,0x00,0x38,0x44,0x82,0x82,0x82,0x9A,0x44,0x3A,0x00,
    /* R */ 0x07,0x00,0xF8,0x84,0x84,0xF8,0x90,0x88,0x88,0x84,0x00,
    /* S */ 0x07,0x00,0x78,0x84,0x80,0x60,0x18,0x04,0x84,0x78,0x00,
    /* T */ 0x06,0x00,0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,
    /* U */ 0x07,0x00,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x78,0x00,
    /* V */ 0x08,0x00,0x82,0x82,0x44,0x44,0x28,0x28,0x10,0x10,0x00,
    /* W */ 0x08,0x00,0x82,0x82,0x44,0x44,0x54,0x54,0x28,0x28,0x00,
    /* X */ 0x07,0x00,0x84,0x48,0x48,0x30,0x30,0x48,0x48,0x84,0x00,
    /* Y */ 0x08,0x00,0x82,0x44,0x44,0x28,0x10,0x10,0x10,0x10,0x00,
    /* Z */ 0x07,0x00,0xFC,0x08,0x10,0x10,0x20,0x20,0x40,0xFC,0x00,
    /* [ */ 0x03,0xC0,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xC0,
    /* \ */ 0x04,0x00,0x80,0x80,0x40,0x40,0x40,0x40,0x20,0x20,0x00,
    /* ] */ 0x03,0xC0,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0xC0,
    /* ^ */ 0x06,0x00,0x20,0x50,0x50,0x88,0x00,0x00,0x00,0x00,0x00,
    /* _ */ 0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ` */ 0x03,0x00,0x80,0x80,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
    /* a */ 0x06,0x00,0x00,0x00,0x70,0x88,0x78,0x88,0x98,0x68,0x00,
    /* b */ 0x06,0x00,0x80,0x80,0xB0,0xC8,0x88,0x88,0xC8,0xB0,0x00,
    /* c */ 0x06,0x00,0x00,0x00,0x70,0x88,0x80,0x80,0x88,0x70,0x00,
    /* d */ 0x06,0x00,0x08,0x08,0x68,0x98,0x88,0x88,0x98,0x68,0x00,
    /* e */ 0x06,0x00,0x00,0x00,0x70,0x88,0xF8,0x80,0x88,0x70,0x00,
    /* f */ 0x04,0x00,0x20,0x40,0xE0,0x40,0x40,0x40,0x40,0x40,0x00,
    /* g */ 0x06,0x00,0x00,0x00,0x68,0x98,0x88,0x98,0x68,0x08,0x70,
    /* h */ 0x06,0x00,0x80,0x80,0xB0,0xC8,0x88,0x88,0x88,0x88,0x00,
    /* i */ 0x02,0x00,0x80,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,
    /* j */ 0x03,0x00,0x40,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x80,
    /* k */ 0x05,0x00,0x80,0x80,0x90,0xA0,0xC0,0xA0,0xA0,0x90,0x00,
    /* l */ 0x02,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,
    /* m */ 0x08,0x00,0x00,0x00,0xA4,0xDA,0x92,0x92,0x92,0x92,0x00,
    /* n */ 0x06,0x00,0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x88,0x00,
    /* o */ 0x06,0x00,0x00,0x00,0x70,0x88,0x88,0x88,0x88,0x70,0x00,
    /* p */ 0x06,0x00,0x00,0x00,0xB0,0xC8,0x88,0xC8,0xB0,0x80,0x80,
    /* q */ 0x06,0x00,0x00,0x00,0x68,0x98,0x88,0x98,0x68,0x08,0x08,
    /* r */ 0x04,0x00,0x00,0x00,0xA0,0xC0,0x80,0x80,0x80,0x80,0x00,
    /* s */ 0x06,0x00,0x00,0x00,0x70,0x88,0x60,0x10,0x88,0x70,0x00,
    /* t */ 0x04,0x00,0x40,0x40,0xE0,0x40,0x40,0x40,0x40,0x60,0x00,
    /* u */ 0x06,0x00,0x00,0x00,0x88,0x88,0x88,0x88,0x98,0x68,0x00,
    /* v */ 0x06,0x00,0x00,0x00,0x88,0x88,0x50,0x50,0x20,0x20,0x00,
    /* w */ 0x08,0x00,0x00,0x00,0x82,0x82,0x54,0x54,0x28,0x28,0x00,
    /* x */ 0x06,0x00,0x00,0x00,0x88,0x50,0x20,0x20,0x50,0x88,0x00,
    /* y */ 0x06,0x00,0x00,0x00,0x88,0x88,0x50,0x50,0x20,0x20,0x40,
    /* z */ 0x06,0x00,0x00,0x00,0xF8,0x10,0x20,0x20,0x40,0xF8,0x00,
    /* { */ 0x04,0x20,0x40,0x40,0x40,0x80,0x40,0x40,0x40,0x40,0x20,
    /* | */ 0x02,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
    /* } */ 0x04,0x80,0x40,0x40,0x40,0x20,0x40,0x40,0x40,0x40,0x80,
    /* ~ */ 0x06,0x00,0x00,0x00,0x00,0x68,0x90,0x00,0x00,0x00,0x00,
    /*	 */ 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

int xCursor = 0;
int yCursor = 0;


void putChar (int ch, int color)
{
  char *byte = &font8x10[ch * 11];
  int x, y, wide = *byte++;

  for (y = 0; y <= 9; y++)
  {
    char b = *byte++;

    for (x = 0; x < wide && x < 8; x++)
    {
      if (b & 0x80) putPixel (x + xCursor, y + yCursor, color);
      b <<= 1;
    }
  }

  xCursor += wide;
}


void writeTextXY (int x, int y, char *string, int color)
{
  xCursor = x;
  yCursor = y;

  while (*string)
    putChar (*string++, color);
}


int textWide (char *string)
{
  int wide = 0;

  while (*string)
  {
    wide += font8x10[*string * 11];
    string++;
  }
  return wide - 1;
}

